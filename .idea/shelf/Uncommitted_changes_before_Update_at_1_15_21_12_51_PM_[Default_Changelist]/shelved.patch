Index: app/src/main/res/layout/activity_main.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".MainActivity\">\n\n    <Button\n        android:id=\"@+id/btnPublish\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Publish\"\n        app:layout_constraintBottom_toTopOf=\"@+id/eTOtherMac\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintHorizontal_bias=\"0.513\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintVertical_bias=\"0.791\" />\n\n    <TextView\n        android:id=\"@+id/textView3\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginBottom=\"20dp\"\n        android:text=\"Your mac\"\n        app:layout_constraintBottom_toTopOf=\"@+id/eTYourMac\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintHorizontal_bias=\"0.491\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintVertical_bias=\"1.0\" />\n\n    <EditText\n        android:id=\"@+id/eTYourMac\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginBottom=\"44dp\"\n        android:ems=\"10\"\n        android:inputType=\"textPersonName\"\n        android:text=\"Your mac\"\n        app:layout_constraintBottom_toTopOf=\"@+id/btnPublish\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintHorizontal_bias=\"0.497\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintVertical_bias=\"1.0\" />\n\n    <EditText\n        android:id=\"@+id/eTOtherMac\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:ems=\"10\"\n        android:inputType=\"textPersonName\"\n        android:text=\"Other mac\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintHorizontal_bias=\"0.497\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintVertical_bias=\"0.881\" />\n\n    <TextView\n        android:id=\"@+id/textView2\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginTop=\"44dp\"\n        android:text=\"Other mac\"\n        app:layout_constraintBottom_toTopOf=\"@+id/eTOtherMac\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toBottomOf=\"@+id/btnPublish\" />\n\n    <Button\n        android:id=\"@+id/btnSubscribe\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginBottom=\"64dp\"\n        android:onClick=\"sendMessage\"\n        android:text=\"Subscribe\"\n        app:layout_constraintBottom_toTopOf=\"@+id/textView3\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintVertical_bias=\"1.0\" />\n\n    <EditText\n        android:id=\"@+id/eTMsg\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:ems=\"10\"\n        android:inputType=\"textPersonName\"\n        android:text=\"Message\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toBottomOf=\"@+id/eTOtherMac\" />\n\n    <Button\n        android:id=\"@+id/btnSend\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Send\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintHorizontal_bias=\"0.666\"\n        app:layout_constraintStart_toEndOf=\"@+id/eTMsg\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintVertical_bias=\"0.978\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/layout/activity_main.xml	(revision a1e6bdb97214d071ba618c2d210059d2392427a7)
+++ app/src/main/res/layout/activity_main.xml	(date 1610711432000)
@@ -108,4 +108,18 @@
         app:layout_constraintTop_toTopOf="parent"
         app:layout_constraintVertical_bias="0.978" />
 
+    <Button
+        android:id="@+id/btnConnectPub"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:text="Connect"
+        app:layout_constraintBottom_toBottomOf="parent"
+        app:layout_constraintEnd_toEndOf="parent"
+        app:layout_constraintHorizontal_bias="1.0"
+        app:layout_constraintStart_toEndOf="@+id/eTMsg"
+        app:layout_constraintTop_toTopOf="parent"
+        app:layout_constraintVertical_bias="0.885" />
+
+
+
 </androidx.constraintlayout.widget.ConstraintLayout>
\ No newline at end of file
Index: app/src/main/java/com/example/testaware/MainActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.testaware;\n\nimport androidx.annotation.NonNull;\nimport androidx.annotation.RequiresApi;\nimport androidx.appcompat.app.AppCompatActivity;\nimport androidx.core.app.ActivityCompat;\n\nimport android.Manifest;\nimport android.annotation.TargetApi;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.pm.PackageManager;\nimport android.net.ConnectivityManager;\nimport android.net.LinkProperties;\nimport android.net.Network;\nimport android.net.NetworkCapabilities;\nimport android.net.NetworkRequest;\nimport android.net.NetworkSpecifier;\nimport android.net.wifi.aware.AttachCallback;\nimport android.net.wifi.aware.DiscoverySessionCallback;\nimport android.net.wifi.aware.IdentityChangedListener;\nimport android.net.wifi.aware.PeerHandle;\nimport android.net.wifi.aware.PublishConfig;\nimport android.net.wifi.aware.PublishDiscoverySession;\nimport android.net.wifi.aware.SubscribeConfig;\nimport android.net.wifi.aware.SubscribeDiscoverySession;\nimport android.net.wifi.aware.WifiAwareManager;\nimport android.net.wifi.aware.WifiAwareNetworkInfo;\nimport android.net.wifi.aware.WifiAwareNetworkSpecifier;\nimport android.net.wifi.aware.WifiAwareSession;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.telephony.TelephonyScanManager;\nimport android.util.Base64;\nimport android.util.Log;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.CheckBox;\nimport android.widget.EditText;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.net.Inet6Address;\nimport java.net.InetAddress;\nimport java.net.NetworkInterface;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\nimport java.util.Enumeration;\nimport java.util.List;\n\n\npublic class MainActivity extends AppCompatActivity {\n\n    private boolean supportsAware;\n    private String LOG = \"LOG-Test-Aware\";\n    private SubscribeDiscoverySession mainSession;\n    private WifiAwareManager wifiAwareManager;\n    private WifiAwareSession wifiAwareSession;\n    private String serviceName = \"Receive-Message-Service\";\n    private Context context;\n    private static final String[] LOCATION_PERMS={\n            Manifest.permission.ACCESS_FINE_LOCATION\n    };\n\n    private static final String[] LOCATION_PERMS_COARSE={\n            Manifest.permission.ACCESS_COARSE_LOCATION\n    };\n    private static final int INITIAL_REQUEST=1337;\n    private static final int LOCATION_REQUEST_COARSE=INITIAL_REQUEST+2;\n    private static final int LOCATION_REQUEST_FINE=INITIAL_REQUEST+3;\n\n\n    private PublishDiscoverySession   publishDiscoverySession;\n    private SubscribeDiscoverySession subscribeDiscoverySession;\n\n    private byte[]                    portOnSystem;\n    private int                       portToUse;\n\n    private byte[]                    myIP;\n    private byte[]                    otherIP;\n    private byte[]                    msgtosend;\n\n    private byte[]                    otherMac;\n    private PeerHandle peerHandle;\n    private byte[] myMac;\n\n    private final int MAC_ADDRESS_MESSAGE = 11;\n    private BroadcastReceiver         broadcastReceiver;\n    private ConnectivityManager       connectivityManager;\n    private NetworkSpecifier          networkSpecifier;\n\n\n    private final int                 IP_ADDRESS_MESSAGE             = 33;\n    private Inet6Address              ipv6;\n\n    private ServerSocket              serverSocket;\n    private final int                 MESSAGE                        = 7;\n\n\n    // Hentet fra:https://github.com/anagramrice/NAN/blob/master/app/src/main/java/net/mobilewebprint/nan/MainActivity.java\n    private static final int MY_PERMISSION_COARSE_LOCATION_REQUEST_CODE = 88;\n    private static final int MY_PERMISSION_FINE_LOCATION_CODE = 99;\n    //-------------------------------------------------------------------------------------------------------------------------\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        context = this;\n\n        wifiAwareManager = null;\n        wifiAwareSession = null;\n        connectivityManager = null;\n        networkSpecifier = null;\n        publishDiscoverySession = null;\n        subscribeDiscoverySession = null;\n        peerHandle = null;\n\n\n        //Button calling the subscribe function\n        Button subscribeBtn = findViewById(R.id.btnSubscribe);\n        subscribeBtn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                subscribe();\n                Log.i(LOG, \"Subscribe button pressed\");\n            }\n        });\n\n        //Button calling the publish function\n        Button publishBtn = findViewById(R.id.btnPublish);\n        publishBtn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                publish();\n                Log.i(LOG, \"Publish button pressed\");\n            }\n        });\n\n        //------------------------------------------------------------------------------------------------------\n        Button send = findViewById(R.id.btnSend);        /* +++++ */\n        send.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                String msg= \"messageToBeSent: \";\n                EditText editText = (EditText)findViewById(R.id.eTMsg);\n                msg += editText.getText().toString();\n                msgtosend = msg.getBytes();\n                if (publishDiscoverySession != null && peerHandle != null) {\n                    publishDiscoverySession.sendMessage(peerHandle, MESSAGE, msgtosend);\n                } else if(subscribeDiscoverySession != null && peerHandle != null) {\n                    subscribeDiscoverySession.sendMessage(peerHandle, MESSAGE, msgtosend);\n                }\n            }\n        });                                                                                   /* ----- */\n        //------------------------------------------------------------------------------------------------------\n\n\n\n        // Hentet fra:https://github.com/anagramrice/NAN/blob/master/app/src/main/java/net/mobilewebprint/nan/MainActivity.java\n        setupPermissions();\n        if (canAccessLocationFine()) {\n            Log.i(LOG,\"Can access fine location\");\n        }\n        else {\n            requestPermissions(LOCATION_PERMS, LOCATION_REQUEST_FINE);\n        }\n\n        if (canAccessLocationCoarse()) {\n            Log.i(LOG,\"Can access coarse location\");\n        }\n        else {\n            requestPermissions(LOCATION_PERMS_COARSE, LOCATION_REQUEST_COARSE);\n        }\n\n\n        // Messages for whether or not device has WiFi Aware\n        //Toast hasAware = Toast.makeText(this, \"WiFi Aware is available\", Toast.LENGTH_LONG);\n        //Toast noAware = Toast.makeText(this, \"WiFi Aware is not available\", Toast.LENGTH_LONG);\n        supportsAware = this.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI_AWARE);\n        if(supportsAware){\n            //hasAware.show();\n            Log.i(LOG, \"The device supports Wi-Fi Aware\");\n\n            //attachToSession();\n        } else {\n            //noAware.show();\n            Log.i(LOG, \"The device DOES NOT supports Wi-Fi Aware\");\n        }\n\n\n        wifiAwareManager = (WifiAwareManager) getSystemService(Context.WIFI_AWARE_SERVICE);\n\n        // Messages for whether or not device has WiFi Aware\n        final Toast awareSupported = Toast.makeText(this, \"Wi-Fi Aware Supported\", Toast.LENGTH_LONG);\n        final Toast awareUnsupported = Toast.makeText(this, \"Wi-Fi Aware Unsupported. Do you have  Wi-Fi or Location OFF? \", Toast.LENGTH_LONG);\n        IntentFilter filter =\n                new IntentFilter(WifiAwareManager.ACTION_WIFI_AWARE_STATE_CHANGED);\n        BroadcastReceiver myReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                // discard current sessions\n                if (wifiAwareManager.isAvailable()) {\n                    awareSupported.show();\n                    //attachToSession();\n                } else {\n                    awareUnsupported.show();\n                }\n            }\n        };\n        this.registerReceiver(myReceiver, filter);\n\n        //Obtain a session, by calling attach(). Joins or forms a WifI aware cluster.\n        wifiAwareManager.attach(new AttachCallback() {\n            @Override\n            public void onAttached(WifiAwareSession session) {\n                super.onAttached(session);\n                Log.i(LOG, \"ON Attached!\");\n                wifiAwareSession = session;\n                //TODO: close session\n            }\n            //TODO: make onattachfailed\n        }, new IdentityChangedListener() {\n            @Override\n            public void onIdentityChanged(byte[] mac) {\n                super.onIdentityChanged(mac);\n                setMacAddress(mac);\n            }\n        }, null);\n\n\n    }\n\n    private void attachToSession(){\n        //Obtain a session, by calling attach(). Joins or forms a WifI aware cluster.\n        wifiAwareManager.attach(new AttachCallback() {\n            @Override\n            public void onAttached(WifiAwareSession session) {\n                super.onAttached(session);\n                Log.i(LOG, \"ON Attached!\");\n                wifiAwareSession = session;\n                //TODO: close session\n            }\n            //TODO: make onattachfailed\n        }, new IdentityChangedListener() {\n            @Override\n            public void onIdentityChanged(byte[] mac) {\n                super.onIdentityChanged(mac);\n                setMacAddress(mac);\n            }\n        }, null);\n\n    }\n\n    private boolean canAccessLocationFine() {\n        return(hasPermission(Manifest.permission.ACCESS_FINE_LOCATION));\n    }\n\n    private boolean canAccessLocationCoarse() {\n        return(hasPermission(Manifest.permission.ACCESS_COARSE_LOCATION));\n    }\n    private boolean hasPermission(String perm) {\n        return(PackageManager.PERMISSION_GRANTED==checkSelfPermission(perm));\n    }\n\n\n    /**\n     * App Permissions for Coarse Location\n     **/\n    private void setupPermissions(){\n        // If we don't have the record network permission...\n        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {\n            // And if we're on SDK M or later...\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n                // Ask again, nicely, for the permissions.\n                String[] permissionsWeNeed = new String[]{ Manifest.permission.ACCESS_COARSE_LOCATION };\n                requestPermissions(permissionsWeNeed, MY_PERMISSION_COARSE_LOCATION_REQUEST_CODE);\n            }\n        }\n\n        //-------------------------------------------------------------------------------------------- +++++\n        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {\n            // And if we're on SDK M or later...\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n                // Ask again, nicely, for the permissions.\n                String[] permissionsWeNeed = new String[]{ Manifest.permission.ACCESS_FINE_LOCATION };\n                requestPermissions(permissionsWeNeed, MY_PERMISSION_FINE_LOCATION_CODE);\n            }\n        }\n        //-------------------------------------------------------------------------------------------- -----\n    }\n\n    @Override\n    public void onRequestPermissionsResult(int requestCode,\n                                           @NonNull String permissions[], @NonNull int[] grantResults) {\n        switch (requestCode) {\n            case MY_PERMISSION_COARSE_LOCATION_REQUEST_CODE: {\n                // If request is cancelled, the result arrays are empty.\n                if (grantResults.length > 0\n                        && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n                    Log.i(LOG, \"Permission for location granted.\");\n                    return;\n\n                } else {\n                    Log.i(LOG, \"Permission for location not granted. NAN can't run.\");\n                    finish();\n                    // The permission was denied, so we can show a message why we can't run the app\n                    // and then close the app.\n                }\n            }\n\n            //-------------------------------------------------------------------------------------------- +++++\n            case MY_PERMISSION_FINE_LOCATION_CODE: {\n                // If request is cancelled, the result arrays are empty.\n                if (grantResults.length > 0\n                        && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n                    Log.i(LOG, \"Fine location permission granted\");\n                    return;\n\n                } else {\n                    Log.i(LOG, \"Fine location permission not granted\");\n                }\n            }\n            //-------------------------------------------------------------------------------------------- -----\n            // Other permissions could go down here\n\n        }\n    }\n\n\n\nprivate void networkRequester(){\n    //ServerSocket ss = null;\n\n    NetworkRequest networkRequest = new NetworkRequest.Builder()\n            .addTransportType(NetworkCapabilities.TRANSPORT_WIFI_AWARE)\n            .setNetworkSpecifier(networkSpecifier)\n            .build();\n    connectivityManager.requestNetwork(networkRequest, new ConnectivityManager.NetworkCallback(){\n        @Override\n        public void onAvailable(Network network) {\n            Log.i(LOG, \"subscribe available\");\n\n        }\n\n        @Override\n        public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) {\n\n            Log.i(LOG, \"capbabilities changed\");\n\n        }\n\n        @Override\n        public void onLost(Network network) {\n\n        }\n\n        //-------------------------------------------------------------------------------------------- +++++\n        @Override\n        public void onLinkPropertiesChanged(Network network, LinkProperties linkProperties) {\n            super.onLinkPropertiesChanged(network, linkProperties);\n            //TODO: create socketServer on different thread to transfer files\n            Toast.makeText(MainActivity.this, \"onLinkPropertiesChanged\", Toast.LENGTH_LONG).show();\n            Log.d(\"myTag\", \"entering linkPropertiesChanged \");\n            try {\n                NetworkInterface awareNetworkInterface = NetworkInterface.getByName(linkProperties.getInterfaceName());\n\n                Enumeration<InetAddress> Addresses = awareNetworkInterface.getInetAddresses();\n                while (Addresses.hasMoreElements()) {\n                    InetAddress addr = Addresses.nextElement();\n                    if (addr instanceof Inet6Address) {\n                        Log.d(\"myTag\", \"netinterface ipv6 address: \" + addr.toString());\n                        if (((Inet6Address) addr).isLinkLocalAddress()) {\n                            ipv6 = Inet6Address.getByAddress(\"WifiAware\",addr.getAddress(),awareNetworkInterface);\n                            myIP = addr.getAddress();\n                            if (publishDiscoverySession != null && peerHandle != null) {\n                                publishDiscoverySession.sendMessage(peerHandle, IP_ADDRESS_MESSAGE, myIP);\n                            } else if(subscribeDiscoverySession != null && peerHandle != null){\n                                subscribeDiscoverySession.sendMessage(peerHandle,IP_ADDRESS_MESSAGE, myIP);\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n            catch (SocketException e) {\n                Log.d(\"myTag\", \"socket exception \" + e.toString());\n            }\n            catch (Exception e) {\n                //EXCEPTION!!! java.lang.NullPointerException: Attempt to invoke virtual method 'java.util.Enumeration java.net.NetworkInterface.getInetAddresses()' on a null object reference\n                Log.d(\"myTag\", \"EXCEPTION!!! \" + e.toString());\n            }\n            startServer(0,3,ipv6);\n            // should be done in a separate thread\n        /*\n        startServer\n        ServerSocket ss = new ServerSocket(0, 5, ipv6);\n        int port = ss.getLocalPort();    */\n            //TODO: need to send this port via messages to other device to finish client conn info\n\n            // should be done in a separate thread\n            // obtain server IPv6 and port number out-of-band\n            //TODO: Retrieve address:port IPv6 before this client thread can be created\n        /*\n        Socket cs = network.getSocketFactory().createSocket(serverIpv6, serverPort);  */\n        }\n        //-------------------------------------------------------------------------------------------- -----\n    });\n\n}\n\n    @TargetApi(26)\n    public void startServer(final int port, final int backlog, final InetAddress bindAddr) {\n        Runnable serverTask = new Runnable() {\n            @Override\n            public void run() {\n                try{\n                    Log.d(\"serverThread\", \"thread running\");\n                    serverSocket = new ServerSocket(port, backlog, bindAddr);\n                    //ServerSocket serverSocket = new ServerSocket();\n                    while (true) {\n                        portOnSystem = portToBytes(serverSocket.getLocalPort());\n                        if (publishDiscoverySession != null && peerHandle != null) {\n                            publishDiscoverySession.sendMessage(peerHandle, MAC_ADDRESS_MESSAGE, portOnSystem);\n                        } else if (subscribeDiscoverySession != null && peerHandle != null)  {\n                            subscribeDiscoverySession.sendMessage(peerHandle, MAC_ADDRESS_MESSAGE, portOnSystem);\n                        }\n                        Log.d(\"serverThread\", \"server waiting to accept on \" + serverSocket.toString());\n                        Socket clientSocket = serverSocket.accept();\n                        DataOutputStream out = new DataOutputStream(new BufferedOutputStream(clientSocket.getOutputStream()));\n                        DataInputStream in = new DataInputStream(new BufferedInputStream(clientSocket.getInputStream()));\n                        byte[] buffer = new byte[4096];\n                        int read;\n                        int totalRead = 0;\n                        FileOutputStream fos = new FileOutputStream(\"/sdcard/Download/newfile\");\n                        Log.d(\"serverThread\", \"Socket being written to begin... \");\n                        while ((read = in.read(buffer)) > 0) {\n                            fos.write(buffer,0,read);\n                            totalRead += read;\n                            if (totalRead%(4096*2500)==0) {//every 10MB update status\n                                Log.d(\"clientThread\", \"total bytes retrieved:\" + totalRead);\n                            }\n                        }\n                        Log.d(\"serverThread\", \"finished file transfer: \" + totalRead);\n\n                    }\n                } catch (IOException e) {\n                    Log.d(\"serverThread\", \"socket exception \" + e.toString());\n                }\n            }\n        };\n        Thread serverThread = new Thread(serverTask);\n        serverThread.start();\n\n    }\n\n    //testing by having subscriber subcribing to published service \"receive_message_service\" and sending message to\n    //the publisher\n    //make a service discoverable by callin publish()\n    private void publish () {\n        //specify name of service and optional match filters\n        PublishConfig config = new PublishConfig.Builder()\n                .setServiceName(serviceName)\n                .build();\n                //TODO: set service specific info ?\n\n        //specify actions when events occur, such when the subscriber receives a message\n        wifiAwareSession.publish(config, new DiscoverySessionCallback() {\n            @Override\n            public void onPublishStarted(PublishDiscoverySession session) {\n                Log.i(LOG, \"publish started\");\n                super.onPublishStarted(session);\n                publishDiscoverySession = session;\n            }\n\n            @RequiresApi(api = Build.VERSION_CODES.Q)\n            @Override\n            public void onMessageReceived(PeerHandle peerHandle_, byte[] message) {\n                super.onMessageReceived(peerHandle, message);\n                if(message.length == 2) {\n                    portToUse = byteToPortInt(message);\n                    Log.d(\"received\", \"will use port number \"+ portToUse);\n                } else if (message.length == 6){\n                    setOtherMacAddress(message);\n                    Toast.makeText(MainActivity.this, \"mac received\", Toast.LENGTH_LONG).show();\n                } else if (message.length == 16) {\n                    setOtherIPAddress(message);\n                    Toast.makeText(MainActivity.this, \"ip received\", Toast.LENGTH_LONG).show();\n                } else if (message.length > 16) {\n                    setMessage(message);\n                    Toast.makeText(MainActivity.this, \"message received\", Toast.LENGTH_LONG).show();\n                }\n                peerHandle = peerHandle_;\n            }\n        }, null);\n    }\n\n\n\n\n    //subsribe method is used to subscribe to a service\n    private void subscribe(){\n        //specify name of the service to subscribe to\n        SubscribeConfig config = new SubscribeConfig.Builder()\n                .setServiceName(serviceName)\n                .build();\n        //DiscoverySessionCallback is specified when events occur, for example when a publisher is discovered\n        //can also use this method to communicate with publisher\n        wifiAwareSession.subscribe(config, new DiscoverySessionCallback() {\n            //Need discoverySession in order to send message\n            @Override\n            public void onSubscribeStarted(SubscribeDiscoverySession session) {\n                super.onSubscribeStarted(session);\n                subscribeDiscoverySession = session;\n\n                Log.i(LOG, \"subscribe started\");\n\n                if (subscribeDiscoverySession != null && peerHandle != null) {\n                    subscribeDiscoverySession.sendMessage(peerHandle, MAC_ADDRESS_MESSAGE, myMac);\n                    Log.d(\"nanSUBSCRIBE\", \"onServiceStarted send mac\");\n                    //Button responderButton = (Button)findViewById(R.id.responderButton);\n                    //Button initiatorButton = (Button)findViewById(R.id.initiatorButton);\n                    //initiatorButton.setEnabled(true);\n                    //responderButton.setEnabled(false);\n                }\n            }\n            //called when matching publishers come into wifi range\n            @RequiresApi(api = Build.VERSION_CODES.Q)\n            @Override\n            public void onServiceDiscovered(PeerHandle peerHandle_, byte[] serviceSpecificInfo, List<byte[]> matchFilter) {\n                super.onServiceDiscovered(peerHandle, serviceSpecificInfo, matchFilter);\n                //String message = \"Hei!\";\n                peerHandle=peerHandle_;\n\n\n                if (subscribeDiscoverySession != null && peerHandle != null) {\n                    subscribeDiscoverySession.sendMessage(peerHandle, MAC_ADDRESS_MESSAGE, myMac);\n                }\n               /* //TODO: hva skjer her?\n               // byte[] messageByte = Base64.encode(message.getBytes(), Base64.DEFAULT);\n                //mainSession.sendMessage(peerHandle, 1, messageByte);\n                //request wifi aware network on subscriber, same as with publisher, just without specifying port.\n\n                //TODO: find out if peerHandle here is identifier for subscriber or publisher\n                //use session (discovery session) and peerhandle obtained from message from subscriber\n                NetworkSpecifier networkSpecifier = new WifiAwareNetworkSpecifier.Builder(subscribeDiscoverySession, peerHandle)\n                        .setPskPassphrase(\"somePassword\")\n                        .build();\n                NetworkRequest myNetworkRequest = new NetworkRequest.Builder()\n                        .addTransportType(NetworkCapabilities.TRANSPORT_WIFI_AWARE)\n                        .setNetworkSpecifier(networkSpecifier)\n                        .build();\n                //use connectivityManager to request wifi aware network on the publisher\n                ConnectivityManager.NetworkCallback callback = new ConnectivityManager.NetworkCallback() {\n                    //creates network object. Can open socket to communicate with server socket on the publisher\n                    //need to know server sockets IP address and port. Get thsese from network capabilities object provided in\n                    //networkcapabilitiesChanged() callback\n                    @Override\n                    public void onAvailable(Network network) {\n\n                    }\n\n                    @Override\n                    public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) {\n                        WifiAwareNetworkInfo peerAwareInfo = (WifiAwareNetworkInfo) networkCapabilities.getTransportInfo();\n                        Inet6Address peerIpv6 = peerAwareInfo.getPeerIpv6Addr();\n                        int peerPort = peerAwareInfo.getPort();\n\n                        try {\n                            Socket socket = network.getSocketFactory().createSocket(peerIpv6, peerPort);\n                        } catch (IOException e) {\n                            e.printStackTrace();\n                        }\n\n                    }\n\n                    @Override\n                    public void onLost(Network network) {\n\n                    }\n                };*/\n\n\n\n            }\n            @Override\n            public void onMessageReceived(PeerHandle peerHandle, byte[] message) {\n                super.onMessageReceived(peerHandle, message);\n                Log.d(\"nanSUBSCRIBE\", \"received message\");\n                Toast.makeText(MainActivity.this, \"received\", Toast.LENGTH_LONG).show();\n                if(message.length == 2) {\n                    portToUse = byteToPortInt(message);\n                    Log.d(\"received\", \"will use port number \"+ portToUse);\n                } else if (message.length == 6){\n                    setOtherMacAddress(message);\n                    Toast.makeText(MainActivity.this, \"mac received\", Toast.LENGTH_LONG).show();\n                } else if (message.length == 16) {\n                    setOtherIPAddress(message);\n                    Toast.makeText(MainActivity.this, \"ip received\", Toast.LENGTH_LONG).show();\n                } else if (message.length > 16) {\n                    setMessage(message);\n                    Toast.makeText(MainActivity.this, \"message received\", Toast.LENGTH_LONG).show();\n                }\n            }\n        }, null);\n\n    }\n\n    /**\n     * Helper to set the status field.\n     */\n    private void setMessage(byte[] msg) {\n        String outmsg = new String(msg).replace(\"messageToBeSent: \",\"\");\n        EditText editText = (EditText) findViewById(R.id.eTMsg);\n        editText.setText(outmsg);\n    }\n\n    private void setMacAddress(byte[] mac) {\n        myMac = mac;\n        String macAddress = String.format(\"%02x:%02x:%02x:%02x:%02x:%02x\", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\n        EditText editText = findViewById(R.id.eTYourMac);\n        editText.setText(macAddress);\n    }\n\n    private void setOtherMacAddress(byte[] mac) {\n        otherMac = mac;\n        String macAddress = String.format(\"%02x:%02x:%02x:%02x:%02x:%02x\", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\n        EditText editText = findViewById(R.id.eTOtherMac);\n        editText.setText(macAddress);\n    }\n\n    //-------------------------------------------------------------------------------------------- +++++\n    private void setOtherIPAddress(byte[] ip) {\n        otherIP = ip;\n        try {\n            String ipAddr = Inet6Address.getByAddress(otherIP).toString();\n            //EditText editText = (EditText) findViewById(R.id.IPv6text);\n            //editText.setText(ipAddr);\n        } catch (UnknownHostException e) {\n            Log.d(\"myTag\", \"socket exception \" + e.toString());\n        }\n    }\n\n\n    public int byteToPortInt(byte[] bytes){\n        return ((bytes[1] & 0xFF) << 8 | (bytes[0] & 0xFF));\n    }\n\n    public byte[] portToBytes(int port){\n        byte[] data = new byte [2];\n        data[0] = (byte) (port & 0xFF);\n        data[1] = (byte) ((port >> 8) & 0xFF);\n        return data;\n    }\n\n\n    //private WifiAwareSession mAwaresession;\n    /*public void onAttached(final WifiAwareSession session) {\n        Log.d(LOG, \"Attach operation completed and can now start discovery sessions\");\n        final byte[] messageSend = new byte[1];\n        messageSend[0] = 104;\n        mAwaresession = session;\n        // Start Subscribe Session\n        SubscribeConfig config = new SubscribeConfig.Builder()\n                .setServiceName(\"Receive_Message_Service\")\n                .build();\n\n        mAwaresession.subscribe(config, new DiscoverySessionCallback() {\n\n            SubscribeDiscoverySession mainSession;\n\n            @Override\n            public void onSubscribeStarted(SubscribeDiscoverySession session) {\n                Log.d(\"Method Called\", \"onSubscribeStarted\");\n                mainSession = session;\n            }\n            @Override\n            public void onServiceDiscovered(PeerHandle peerHandle, byte[] serviceSpecificInfo,\n                                            List<byte[]> matchFilter) {\n                Log.d(\"Method Called\", \"onServiceDiscovered\");\n                mainSession.sendMessage(peerHandle, 1, messageSend);\n            }\n            @Override\n            public void onMessageReceived(PeerHandle peerHandle, byte[] messageFromPub) {\n                Log.d(\"Method Called\", \"onMessageReceived\");\n                Log.d(\"Messaged Received is\", new String(messageFromPub));\n                //messageReceived = messageFromPub;\n            }}, null);\n        };*/\n\n\n\n\n   /* An application must use {@link #attach(AttachCallback, Handler)} to initialize a\n *     Aware cluster - before making any other Aware operation. Aware cluster membership is a\n *     device-wide operation - the API guarantees that the device is in a cluster or joins a\n *     Aware cluster (or starts one if none can be found). Information about attach success (or\n *     failure) are returned in callbacks of {@link AttachCallback}. Proceed with Aware\n *     discovery or connection setup only after receiving confirmation that Aware attach\n *     succeeded - {@link AttachCallback#onAttached(WifiAwareSession)}. When an\n *     application is finished using Aware it <b>must</b> use the\n *     {@link WifiAwareSession#close()} API to indicate to the Aware service that the device\n *     may detach from the Aware cluster. The device will actually disable Aware once the last\n *     application detaches.\n *\n *\n *  An application <b>must</b> call {@link WifiAwareSession#close()} when done with the\n    * Wi-Fi Aware object.\n    * <p>\n    * Note: a Aware cluster is a shared resource - if the device is already attached to a cluster\n    * then this function will simply indicate success immediately using the same {@code\n    * attachCallback}.\n    *\n    * * @param handler The Handler on whose thread to execute the callbacks of the {@code\n    * attachCallback} object. If a null is provided then the application's main thread will be\n    *                used.\n*/\n\n   /*TODO: create toast which indicates if you have joined or formed a cluster depending on attach success/failure (AttachCallback)*/\n/*\n    public void attach(AttachCallback attachCallback, Handler handler) {\n        attach(attachCallback, handler);\n        attachCallback.toString()\n    }*/\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/testaware/MainActivity.java	(revision a1e6bdb97214d071ba618c2d210059d2392427a7)
+++ app/src/main/java/com/example/testaware/MainActivity.java	(date 1610711432000)
@@ -19,6 +19,7 @@
 import android.net.NetworkRequest;
 import android.net.NetworkSpecifier;
 import android.net.wifi.aware.AttachCallback;
+import android.net.wifi.aware.DiscoverySession;
 import android.net.wifi.aware.DiscoverySessionCallback;
 import android.net.wifi.aware.IdentityChangedListener;
 import android.net.wifi.aware.PeerHandle;
@@ -111,6 +112,8 @@
     private static final int MY_PERMISSION_COARSE_LOCATION_REQUEST_CODE = 88;
     private static final int MY_PERMISSION_FINE_LOCATION_CODE = 99;
     //-------------------------------------------------------------------------------------------------------------------------
+
+    private boolean isPublisher = false;
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
@@ -143,6 +146,21 @@
             public void onClick(View v) {
                 publish();
                 Log.i(LOG, "Publish button pressed");
+                isPublisher = true;
+            }
+        });
+
+        Button connectBtn = findViewById(R.id.btnConnectPub);
+        connectBtn.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
+                    try {
+                        requestWiFiConnectionPublisher(peerHandle, publishDiscoverySession);
+                    } catch (IOException e) {
+                        e.printStackTrace();
+                    }
+                }
             }
         });
 
@@ -238,6 +256,7 @@
         }, null);
 
 
+
     }
 
     private void attachToSession(){
@@ -338,130 +357,6 @@
 
 
 
-private void networkRequester(){
-    //ServerSocket ss = null;
-
-    NetworkRequest networkRequest = new NetworkRequest.Builder()
-            .addTransportType(NetworkCapabilities.TRANSPORT_WIFI_AWARE)
-            .setNetworkSpecifier(networkSpecifier)
-            .build();
-    connectivityManager.requestNetwork(networkRequest, new ConnectivityManager.NetworkCallback(){
-        @Override
-        public void onAvailable(Network network) {
-            Log.i(LOG, "subscribe available");
-
-        }
-
-        @Override
-        public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) {
-
-            Log.i(LOG, "capbabilities changed");
-
-        }
-
-        @Override
-        public void onLost(Network network) {
-
-        }
-
-        //-------------------------------------------------------------------------------------------- +++++
-        @Override
-        public void onLinkPropertiesChanged(Network network, LinkProperties linkProperties) {
-            super.onLinkPropertiesChanged(network, linkProperties);
-            //TODO: create socketServer on different thread to transfer files
-            Toast.makeText(MainActivity.this, "onLinkPropertiesChanged", Toast.LENGTH_LONG).show();
-            Log.d("myTag", "entering linkPropertiesChanged ");
-            try {
-                NetworkInterface awareNetworkInterface = NetworkInterface.getByName(linkProperties.getInterfaceName());
-
-                Enumeration<InetAddress> Addresses = awareNetworkInterface.getInetAddresses();
-                while (Addresses.hasMoreElements()) {
-                    InetAddress addr = Addresses.nextElement();
-                    if (addr instanceof Inet6Address) {
-                        Log.d("myTag", "netinterface ipv6 address: " + addr.toString());
-                        if (((Inet6Address) addr).isLinkLocalAddress()) {
-                            ipv6 = Inet6Address.getByAddress("WifiAware",addr.getAddress(),awareNetworkInterface);
-                            myIP = addr.getAddress();
-                            if (publishDiscoverySession != null && peerHandle != null) {
-                                publishDiscoverySession.sendMessage(peerHandle, IP_ADDRESS_MESSAGE, myIP);
-                            } else if(subscribeDiscoverySession != null && peerHandle != null){
-                                subscribeDiscoverySession.sendMessage(peerHandle,IP_ADDRESS_MESSAGE, myIP);
-                            }
-                            break;
-                        }
-                    }
-                }
-            }
-            catch (SocketException e) {
-                Log.d("myTag", "socket exception " + e.toString());
-            }
-            catch (Exception e) {
-                //EXCEPTION!!! java.lang.NullPointerException: Attempt to invoke virtual method 'java.util.Enumeration java.net.NetworkInterface.getInetAddresses()' on a null object reference
-                Log.d("myTag", "EXCEPTION!!! " + e.toString());
-            }
-            startServer(0,3,ipv6);
-            // should be done in a separate thread
-        /*
-        startServer
-        ServerSocket ss = new ServerSocket(0, 5, ipv6);
-        int port = ss.getLocalPort();    */
-            //TODO: need to send this port via messages to other device to finish client conn info
-
-            // should be done in a separate thread
-            // obtain server IPv6 and port number out-of-band
-            //TODO: Retrieve address:port IPv6 before this client thread can be created
-        /*
-        Socket cs = network.getSocketFactory().createSocket(serverIpv6, serverPort);  */
-        }
-        //-------------------------------------------------------------------------------------------- -----
-    });
-
-}
-
-    @TargetApi(26)
-    public void startServer(final int port, final int backlog, final InetAddress bindAddr) {
-        Runnable serverTask = new Runnable() {
-            @Override
-            public void run() {
-                try{
-                    Log.d("serverThread", "thread running");
-                    serverSocket = new ServerSocket(port, backlog, bindAddr);
-                    //ServerSocket serverSocket = new ServerSocket();
-                    while (true) {
-                        portOnSystem = portToBytes(serverSocket.getLocalPort());
-                        if (publishDiscoverySession != null && peerHandle != null) {
-                            publishDiscoverySession.sendMessage(peerHandle, MAC_ADDRESS_MESSAGE, portOnSystem);
-                        } else if (subscribeDiscoverySession != null && peerHandle != null)  {
-                            subscribeDiscoverySession.sendMessage(peerHandle, MAC_ADDRESS_MESSAGE, portOnSystem);
-                        }
-                        Log.d("serverThread", "server waiting to accept on " + serverSocket.toString());
-                        Socket clientSocket = serverSocket.accept();
-                        DataOutputStream out = new DataOutputStream(new BufferedOutputStream(clientSocket.getOutputStream()));
-                        DataInputStream in = new DataInputStream(new BufferedInputStream(clientSocket.getInputStream()));
-                        byte[] buffer = new byte[4096];
-                        int read;
-                        int totalRead = 0;
-                        FileOutputStream fos = new FileOutputStream("/sdcard/Download/newfile");
-                        Log.d("serverThread", "Socket being written to begin... ");
-                        while ((read = in.read(buffer)) > 0) {
-                            fos.write(buffer,0,read);
-                            totalRead += read;
-                            if (totalRead%(4096*2500)==0) {//every 10MB update status
-                                Log.d("clientThread", "total bytes retrieved:" + totalRead);
-                            }
-                        }
-                        Log.d("serverThread", "finished file transfer: " + totalRead);
-
-                    }
-                } catch (IOException e) {
-                    Log.d("serverThread", "socket exception " + e.toString());
-                }
-            }
-        };
-        Thread serverThread = new Thread(serverTask);
-        serverThread.start();
-
-    }
 
     //testing by having subscriber subcribing to published service "receive_message_service" and sending message to
     //the publisher
@@ -663,6 +558,54 @@
     }
 
 
+    private int port;
+    @RequiresApi(api = Build.VERSION_CODES.Q)
+    private void requestWiFiConnectionPublisher(PeerHandle peerHandle, DiscoverySession discoverySession) throws IOException {
+
+        if (isPublisher){
+            //starting serverSocket on publisher device
+            ServerSocket serverSocket = new ServerSocket(0);
+            port = serverSocket.getLocalPort();
+
+            NetworkSpecifier networkSpecifier = new WifiAwareNetworkSpecifier.Builder(discoverySession, peerHandle)
+                    .setPskPassphrase("somePassword")
+                    .setPort(port)
+                    .build();
+
+        } else{
+            NetworkSpecifier networkSpecifier = new WifiAwareNetworkSpecifier.Builder(discoverySession, peerHandle)
+                    .setPskPassphrase("somePassword")
+                    .build();
+        }
+
+        connectivityManager = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);
+
+
+        NetworkRequest myNetworkRequest = new NetworkRequest.Builder()
+                .addTransportType(NetworkCapabilities.TRANSPORT_WIFI_AWARE)
+                .setNetworkSpecifier(networkSpecifier)
+                .build();
+        ConnectivityManager.NetworkCallback callback = new ConnectivityManager.NetworkCallback() {
+            @Override
+            public void onAvailable(Network network) {
+
+            }
+
+            @Override
+            public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) {
+
+            }
+
+            @Override
+            public void onLost(Network network) {
+
+            }
+        };
+        connectivityManager.requestNetwork(myNetworkRequest, callback);
+    }
+
+
+
     //private WifiAwareSession mAwaresession;
     /*public void onAttached(final WifiAwareSession session) {
         Log.d(LOG, "Attach operation completed and can now start discovery sessions");
Index: .idea/gradle.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"GradleMigrationSettings\" migrationVersion=\"1\" />\n  <component name=\"GradleSettings\">\n    <option name=\"linkedExternalProjectsSettings\">\n      <GradleProjectSettings>\n        <option name=\"testRunner\" value=\"PLATFORM\" />\n        <option name=\"distributionType\" value=\"DEFAULT_WRAPPED\" />\n        <option name=\"externalProjectPath\" value=\"$PROJECT_DIR$\" />\n        <option name=\"gradleJvm\" value=\"1.8\" />\n        <option name=\"modules\">\n          <set>\n            <option value=\"$PROJECT_DIR$\" />\n            <option value=\"$PROJECT_DIR$/app\" />\n          </set>\n        </option>\n        <option name=\"resolveModulePerSourceSet\" value=\"false\" />\n      </GradleProjectSettings>\n    </option>\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/gradle.xml	(revision a1e6bdb97214d071ba618c2d210059d2392427a7)
+++ .idea/gradle.xml	(date 1610454051000)
@@ -15,6 +15,7 @@
           </set>
         </option>
         <option name="resolveModulePerSourceSet" value="false" />
+        <option name="useQualifiedModuleNames" value="true" />
       </GradleProjectSettings>
     </option>
   </component>
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_1_7\" default=\"true\" project-jdk-name=\"1.8\" project-jdk-type=\"JavaSDK\">\n    <output url=\"file://$PROJECT_DIR$/build/classes\" />\n  </component>\n  <component name=\"ProjectType\">\n    <option name=\"id\" value=\"Android\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/misc.xml	(revision a1e6bdb97214d071ba618c2d210059d2392427a7)
+++ .idea/misc.xml	(date 1610454051000)
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_7" default="true" project-jdk-name="1.8" project-jdk-type="JavaSDK">
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_8" default="true" project-jdk-name="1.8" project-jdk-type="JavaSDK">
     <output url="file://$PROJECT_DIR$/build/classes" />
   </component>
   <component name="ProjectType">
